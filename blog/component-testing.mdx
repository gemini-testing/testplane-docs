---
title: Компонентное тестирование
slug: component-testing-intro
hide_table_of_contents: false
date: 2024-06-10T14:00
---

import Admonition from "@theme/Admonition";

В testplane в экспериментальном режиме поддержали компонентное тестирование и unit-тесты, выполняющиеся в браузере.

<!-- truncate -->

Практически все современные веб-интерфейсы пишутся с использованием фреймворков (React, Vue, Svelte, ...) для упрощения создания и реиспользования компонентов. Такие компоненты важно тестировать в изоляции друг от друга, чтобы быть уверенным, что каждый компонент корректно справляется со своей работой. Точно так же как мы пишем unit-тесты отдельно от интеграционных. В Testplane уже поддержанно скриншотное тестирование компонентов с помощью [Storybook](https://storybook.js.org/), однако этот инструмент актуален не для всех проектов. Поэтому мы разработали ещё один вариант компонентного тестирования, который не требует использования Storybook.

Данная возможность может быть полезна, если у вас в проекте используются React-компоненты. При этом тестов нет совсем или используются только тяжелые интеграционные тесты (т.е. проверяются целые страницы, содержащие множество компонентов). Согласно [пирамиде тестирования](https://martinfowler.com/articles/practical-test-pyramid.html), интеграционных тестов должно быть меньше всего так как они больше подвержены “флапам” и зачастую избыточны. Множество сценариев можно проверить с помощью компонентых тестов и тем самым сократить время выполнения тестов в CI и улучшить их стабильность.

### Варианты реализации компонентного тестирования

Компонентное тестирование — это вид тестирования, при котором логика работы веб-компонента проверяется в изоляции от веб-страницы, в которой он используется. Для того, чтобы выполнить такой тест, нужно уметь корректно рендерить компонент. Часто для этой задачи применяют [JSDom](https://github.com/jsdom/jsdom) (используется в [Jest](https://jestjs.io/)), который рендерит веб-компоненты с помощью виртуального рендеринга Node.js, т.е. без использования реального браузера. С одной стороны, это работает быстрее (браузер не поднимается), а с другой — менее стабильно, так как проверки выполняются не в реальном браузере. Второе популярное решение — это использовать очень быстрый dev-сервер [Vite](https://vitejs.dev/), который поддерживает множество фреймворков (React, Vue, Svelte, ...) и отвечает за рендеринг компонентов в изоляции.

Мы остановились на варианте с использованием Vite, так как такой подход обеспечивает тестирование страницы более приближенное к реальности (как если бы ее открыл пользователь). При этом, сами тесты выполняются немного дольше, чем в jsdom. Но для нас самое главное стабильность и воспроизводимость результатов тестов, поэтому выбор был очевиден.

<details>
    <summary>Краткая информация о том, как это реализовано</summary>

    - при указании опции `testRunEnv: 'browser'` в конфиге Testplane, будет использован браузерный раннер, который поднимает Vite на localhost с рандомным свободным портом (пользователь может выставить необходимый порт в конфиге Vite). Именно на этом поднятом сервере будут рендерится все пользовательские компоненты и выполняться все необходимые команды/проверки (т.е. прямо внутри браузера);
    - затем читаются тесты в Node.js, т.е. как это делается и для интеграционных тестов. Это необходимо, чтобы все плагины работали корректно (речь про триггер событий при чтении тестов), а так же, чтобы была возможность запустить тесты из одного файла параллельно. Если бы тест читался только в контексте браузера, то приходилось бы запускать абсолютно все тесты внутри одного файла и критическое завершение в одном из них приводило бы к остановке всех последующих. Т.е. на данном этапе мы понимаем какие тесты нужно запустить;
    - после чего, как обычно, поднимаются необходимые браузеры и в них запускаются тесты. Каждый тест перед выполнением пользовательского кода выполняет переход на поднятый сервер Vite. При выполнении такого запроса генерится специальный index.html, в который подгружаются все необходимые библиотеки:
    - mocha — для чтения тестов;
    - webdriverio — для использования инстанса браузера внутри самого браузера;
    - expect — для выполнения проверок;
    - и прочие внутренние модули, необходимые для корректной работы.
    - при открытии index.html из Vite, браузер устанавливает websocket-соединение с мастер процессом Testplane для того, чтобы обмениваться необходимыми данными. Например, в случае, если в браузере вызывается конструкция `await browser.$("body").assertView("plain", "body")`, то очевидно, что она выполниться в самом браузере не может, так как внутри `assertView` нам необходим доступ к файловой системе. Поэтому, выполнение этой команды отправляется в мастер Testplane, который в свою очередь отправляет ее worker-у, в котором данный тест запущен. И именно worker выполняет переданную ему команду. Когда результат получен, он таким же образом отправляется назад в браузер. Все общение реализовано с помощью библиотеки [socket.io](https://socket.io/);
    - после чего, в браузере начинает выполняться указанный тест, который по завершению возвращает результат в Node.js процесс.

</details>

### Как использовать?

Будем настраивать тестирование react-компонентов, написанных на TypeScript. Поэтому, для начала установим необходимые зависимости:

```bash
npm i testplane vite @vitejs/plugin-react @testing-library/react --save-dev
npm i react --save
```

Создаем Vite конфиг, в котором подключим плагин для поддержки React. Пример:

```javascript
// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
    plugins: [react()],
});
```

Теперь настроим запуск тестов в браузере. Для этого укажем опцию [testRunEnv](https://github.com/gemini-testing/testplane/blob/master/docs/config.md#testrunenv). Пример:

```javascript
// .testplane.conf.ts
export const {
    // ...
    system: {
        // ...
        testRunEnv: ['browser', { viteConfig: './vite.config.ts' }],
    },
    sets: {
        linux: {
            files: [
                'src/tests/**/*.testplane.tsx'
            ],
            browsers: [
                'chrome'
            ]
        },
    },
}
```

После чего можем написать тест, в котором просто выведем значение `document` в консоль без использования команды [browser.execute](/docs/v8/commands/browser/execute):

```javascript
// src/tests/test.testplane.tsx
it("should log document", async () => {
    console.log(document);
});
```

Если бы такой тест выполнялся в окружении Node.js, то он бы упал с ошибкой `ReferenceError: document is not defined`. Но в нашем случае он будет выполнен прямо в браузере, где доступна глобальная переменная `document`. Поэтому, в логе браузера и терминала (про эту возможность расскажем ниже) мы увидим следующее:

```
{
  location: {
    ancestorOrigins: {},
    href: 'http://localhost:56292/run-uuids/23d2af81-4259-425c-8214-c9e770d75ea4',
    origin: 'http://localhost:56292',
    protocol: 'http:',
    host: 'localhost:56292',
    hostname: 'localhost',
    port: '56292',
    pathname: '/run-uuids/23d2af81-4259-425c-8214-c9e770d75ea4',
    search: '',
    hash: ''
  }
}
```

Напишем более сложный тест с рендерингом react компонента:

```javascript
// src/tests/test.testplane.tsx
import { useState } from "react";
import { render } from "@testing-library/react";

// Простой компонент с тайтлом и кнопкой-счетчиком
function Component() {
    const [count, setCount] = useState(0);

    return (
        <div id="root">
            <h1>Testplane Component Testing</h1>
            <button onClick={() => setCount(count => count + 1)}>count is {count}</button>
        </div>
    );
}

it("should render react button", async ({ browser }) => {
    render(<Component />); // рендерим компонент на сгенеренной странице Vite

    const button = await browser.$("button");

    await button.click();
    await button.click();

    await expect(button).toHaveText("count is 2");
});
```

С полноценно работающими примерами можно ознакомиться [здесь](https://github.com/gemini-testing/testplane/tree/master/examples/component-testing).

<Admonition type="warning" title="На данный момент есть ограничения">
    - поддерживаются только компоненты, написанные на React в файлах `.jsx` и `.tsx`. Поддержка Vue
    также есть в планах; - нет доступа к `currentTest` из хуков и теста; - временно не
    поддерживается плагин @testplane/global-hook.
</Admonition>

### Какие дополнительные возможности поддерживаются?

#### Hot Module Replacement (HMR)

В Vite поддерживается [HMR](https://vitejs.dev/guide/api-hmr.html). Это означает, что если изменить загруженный файл, то произойдет или ремаунт компонента, или полная перезагрузка страницы. В случае, если компонент описан в отдельном файле (т.е. не в одном файле с тестом), то будет выполнен ремаунт, но тест перезапущен не будет. А если изменить файл с тестом, то произойдет перезагрузка страницы, которая приведет к тому, что Testplane прервет выполнение текущего теста и запустит его заново. За счет такой возможности в Vite можно очень быстро разрабатывать компоненты и писать для них тесты. Рекомендуется использовать вместе с REPL-режимом.

При изменении исходников компонента не происходит полного перезапуска теста (маунтится по новой только сам компонент). При этом, если изменить код теста, то происходит полный перезапуск.

#### Использование инстанса browser и expect прямо в DevTools браузера

В консоли браузера, в котором выполняется тест, доступны инстанс самого `browser` и инстанс `expect`. Это довольно удобно использовать при дебаге теста.

#### Логи из консоли браузера в терминале

Вызов команд `log`, `info`, `warn`, `error`, `debug` и `table` на объекте `console` в браузере приводят к тому, что отображается информация не только в DevTools браузера, но также и в терминале, из которого был запущен Testplane. Т.е. можно вызвать `console.log` в тесте/компоненте и затем увидеть результат его выполнения в терминале. Это также довольно удобно при дебаге теста.

### Заключение

Данная функциональность предоставляет нашим пользователям новые возможности:

-   изолированное тестирование React-компонентов в реальном браузере;
-   стабильность и воспроизводимость результатов тестов в сравнении с JSDom;
-   поддержка HMR;
-   доступ к инстансам browser/expect в DevTools браузера, для удобного дебага;
-   отображение логов в терминале для повышения комфорта и увеличения скорости разработки.

Переезжайте на Testplane и попробуйте новую возможность самостоятельно. В случае обнаружения проблем, приходите в [issue github](https://github.com/gemini-testing/testplane/issues) — мы вам обязательно поможем!
