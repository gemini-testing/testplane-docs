# Селекторы

Testplane предоставляет множество способов для поиска элементов на странице браузера.

## WebDriverIO

В Testplane поддерживается поиск элементов, совместимый с синтаксисом WebdriverIO: по CSS селекторам, по XPath, по тексту элементов и по другим признакам, которые описаны ниже.

### CSS селекторы

#### По классу

Чтобы найти элемент на странице по классу, используйте селектор `".class-name"`.

```javascript
describe("CSS-селектор по классу", () => {
    it("Поиск элемента на главной странице", async ({ browser }) => {
        await browser.openAndWait("https://testplane.io/");
        
        // Ищем элемент по классу "navbar"
        const navbar = await browser.$(".navbar");
        
        // Проверяем, отображается ли элемент на странице
        const isDisplayed = await navbar.isDisplayed();
        console.log("Навбар отображается:", isDisplayed);
    });
});
```

Стоит использовать, если:

-   класс является стабильным и не генерируется динамически;
-   нужен быстрый и простой способ найти элемент;
-   класс семантически описывает элемент (например, `.error-message`, `.success-banner`);
-   вы работаете с компонентными библиотеками, где классы являются частью API.

#### По id

Чтобы найти элемент по `id`, используйте селектор вида `"#id"`.

```javascript
describe("CSS-селектор по id", () => {
    it("Поиск элемента по id на главной странице", async ({ browser }) => {
        await browser.openAndWait("https://testplane.io/");
        
        // Ищем элемент по id "__docusaurus"
        const main = await browser.$("#__docusaurus");
        
        // Проверяем, отображается ли элемент на странице
        const isDisplayed = await main.isDisplayed();
        console.log("Элемент отображается:", isDisplayed);
    });
});
```

Стоит использовать, если:

-   вам необходим быстрый и простой способ поиска элементов;
-   `id` является частью публичного API компонента;
-   нужна максимальная производительность селектора (`id` — самый быстрый селектор).

#### По типу атрибута

Для поиска элемента по атрибуту, используйте селектор вида `input[type="name"]`.

```javascript
describe("CSS-селектор по типу атрибута", () => {
    it("Поиск элемента по типу атрибута", async ({ browser }) => {
        await browser.openAndWait("https://testplane.io/");
        
        // Ищем кнопку по атрибуту type="button"
        // Формат селектора: element[type="value"]
        const button = await browser.$('button[type="button"]');
        
        // Проверяем существование элемента в DOM
        const isExisting = await button.isExisting();
        console.log("Кнопка существует:", isExisting);
    });
});
```

Стоит использовать, если:

-   нужно найти все элементы определённого типа (все чекбоксы, все радиокнопки);
-   нужно работать с семантическими HTML5 типами (`email`, `tel`, `url`, `date`).

#### CSS-селекторы по атрибуту data-testid

Для поиска элементов, которые помечены для тестирования, используйте селекторы по атрибуту `data-testid`.

```javascript
describe("CSS-селектор по атрибуту data-testid", () => {
    it("Поиск элемента по data-testid", async ({ browser }) => {
        // Открываем страницу и ждем её загрузки
        await browser.openAndWait("https://testplane.io/");
        
        // Ищем элемент по атрибуту data-testid
        const element = await browser.$('[data-testid="main-content"]');
        
        // Проверяем существование элемента в DOM
        const isExisting = await element.isExisting();
        console.log("Элемент с data-testid существует:", isExisting);
    });
});
```

Стоит использовать, если:

-   создаёте селекторы специально для тестирования;
-   нужна стабильность селекторов независимо от изменений UI/стилей.

### XPath селекторы

#### По тексту элемента

Чтобы найти элемент по содержащемуся в нем тексту, используйте селектор `//element[text()="text"]`.

```javascript
// Точное совпадение текста
describe("XPath-селектор по тексту элемента", () => {
    it("Поиск элемента по тексту", async ({ browser }) => {
        await browser.openAndWait("https://testplane.io/");
        
        // Ищем элемент по тексту внутри него
        const link = await browser.$('//a[text()="Docs"]');
        
        // Проверяем существование элемента в DOM
        const isExisting = await link.isExisting();
        console.log("Элемент с текстом существует:", isExisting);
    });
});
```

Стоит использовать, если:

-   текст элемента уникален и стабилен (названия кнопок, заголовки);
-   другие стратегии поиска элементов оказались неприменимы.

#### По атрибутам

Для поиска элемента по атрибуту, используйте селектор вида `//element[@type="atribute"]`.

```javascript
describe("XPath-селектор по атрибуту", () => {
    it("Поиск элемента по атрибуту", async ({ browser }) => {
        await browser.openAndWait("https://testplane.io/");
        
        // Ищем элемент по атрибуту type
        const button = await browser.$('//button[@type="button"]');
        
        // Проверяем существование элемента в DOM
        const isExisting = await button.isExisting();
        console.log("Элемент с атрибутом существует:", isExisting);
    });
});
```

Стоит использовать, если:

-   нужны сложные условия поиска (комбинации атрибутов);
-   работаете с динамическими атрибутами (`data`-атрибуты с переменными значениями);
-   нужна гибкость в поиске (частичные совпадения, начало/конец строки);
-   CSS-селекторы не могут выразить нужную логику;
-   нужно найти элемент по отсутствию атрибута.

#### Навигация по DOM

Исползуя XPath, вы можете навигировать по DOM-дереву.

```javascript
// Прямой родитель
const parentDiv = await browser.$("//input[@name="email"]/..");

// Предок с условием
const formContainer = await browser.$("//input[@name="email"]/ancestor::form[@id="registration"]");

// Следующий сиблинг
const errorLabel = await browser.$("//input[@class="invalid"]/following-sibling::span[@class="error"][1]");

// Предыдущий сиблинг
const label = await browser.$("//input[@name="password"]/preceding-sibling::label[1]");

// Все потомки
const allInputs = await browser.$$("//form[@id="checkout"]//input");

// Прямые дети
const directChildren = await browser.$$("//ul[@class="menu"]/li");

// Поиск «дяди» элемента (родитель -> сиблинг родителя)
const siblingSection = await browser.$("//h2[text()="Контакты"]/../following-sibling::section[1]");
```

Подобный вид навигации по дереву не рекомендуется использовать из-за своей хрупкости, но он возможен.

#### XPath: индексы и позиции

XPath позволяет выбирать элементы по их позиции в наборе результатов.

```javascript
describe("XPath-селектор: индексы и позиции", () => {
    it("Поиск элемента по индексу", async ({ browser }) => {
        await browser.openAndWait("https://testplane.io/");
        
        // Ищем третий элемент ссылки в навигации (индекс начинается с 1)
        // Формат селектора: (//element)[index]
        const thirdLink = await browser.$('(//a)[3]');
        
        // Ждем появления элемента и его отображения
        await thirdLink.waitForDisplayed({ timeout: 5000 });
        
        // Проверяем существование элемента в DOM
        const isExisting = await thirdLink.isExisting();
        console.log("Третий элемент существует:", isExisting);
        
        // Получаем текст элемента
        const text = await thirdLink.getText();
        console.log("Текст третьего элемента:", text);
    });
});
```

Стоит использовать, если:

-   нужен доступ к элементу по его позиции в наборе результатов;
-   тестируете пагинацию или списки с определённым порядком;
-   работаете с таблицами и нужна конкретная строка;
-   нужен первый или последний элемент среди нескольких одинаковых;
-   тестируете сортировку (проверка, что элемент на правильной позиции).

### Селекторы по Link Text

Селекторы по содержащемуся внутри тексту позволяют находить ссылки `(<a>)` по их тексту. Используйте `="text"`, чтобы найти элемент с точным текстом и `*="text"` для поиска по частичному совпадению текста.

```javascript
describe('Селектор Link Text', () => {
    it('Поиск элемента по совпадающему тексту', async ({ browser }) => {
        await browser.url('https://testplane.io/ru/');
        
        // Полное совпадение текста ссылки
        const docsLink = await browser.$('=Документация');
        const isDocsLinkFound = await docsLink.isExisting();
        console.log(`Элемент с полным текстом "Документация" найден: ${isDocsLinkFound}`);
        
        // Частичное совпадение текста ссылки
        const partialLink = await browser.$('*=Докум');
        const isPartialLinkFound = await partialLink.isExisting();
        console.log(`Элемент с частичным текстом "Докум" найден: ${isPartialLinkFound}`);
        
        // Частичное совпадение с указанием тега <a>
        const tagPartialLink = await browser.$('a*=Документ');
        const isTagPartialLinkFound = await tagPartialLink.isExisting();
        console.log(`Элемент <a> с частичным текстом "Документ" найден: ${isTagPartialLinkFound}`);
        
        // Case-insensitive поиск с тегом div
        const divCaseInsensitive = await browser.$('div.=testplane');
        const isDivCaseInsensitiveFound = await divCaseInsensitive.isExisting();
        console.log(`Элемент <div> с case-insensitive текстом "testplane" найден: ${isDivCaseInsensitiveFound}`);
    });
});
```

Стоит использовать, если:

-   текст элементов стабилен;
-   вам необходимо, чтобы тест был максимально приближен к реальным пользовательским сценариям.


### Shadow DOM селекторы

Shadow DOM селекторы позволяют работать с элементами внутри Shadow DOM — инкапсулированной части DOM-дерева. Например, если у вас есть кастомный элемент `my-custom-element`, вы можете найти кнопку внутри его Shadow DOM с помощью `shadow$("button")`.

```javascript
// Простой доступ в Shadow DOM
const customElement = await browser.$("my-custom-element");
const button = await customElement.shadow$("button");
await button.click();

// Множественные элементы в Shadow DOM
const slotElements = await customElement.shadow$$(".slot-item");
```

Стоит использовать, если:

-   работаете с Web Components и Custom Elements;
-   приложение использует Shadow DOM для инкапсуляции стилей;
-   тестируете компоненты из сторонних библиотек (Lit, Stencil, native Web Components);
-   нужен доступ к элементам внутри shadow root;
-   работаете с дизайн-системой на базе Web Components.

## Testing-library

Testing Library позволяет искать элементы так, как их ищут на странице пользователи — по тексту, типу элемента или другим атрибутам, которые не зависят от деталей вашей верстки.

### ByRole

`getByRole` — основной метод в Testing Library, который позволяет находить элементы по их ARIA-ролям. Например, если вы используете метод `screen.getByRole("button", { name: /submit/i })`, то найдете кнопку с текстом, содержащим `submit`.

```javascript
describe("getByRole", () => {
    it("Поиск кнопки с помощью метода getByRole", async ({ browser }) => {
        await browser.url("https://testplane.io/");

        const button = await browser.getByRole("button", { name: "Get started" });

        await button.click();
    });
});
```

### ByLabelText

Для поиска элементов форм по тексту их меток (`label`), используйте метод `getByLabelText`.

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Поиск по тексту label (полное совпадение)
const emailInput = screen.getByLabelText("Email Address");
await userEvent.type(emailInput, "user@example.com");

// Поиск с регулярным выражением (частичное совпадение, case-insensitive)
const passwordInput = screen.getByLabelText(/password/i);
await userEvent.type(passwordInput, "secure123");
```

### ByPlaceholderText

Чтобы найти поле ввода по тексту `placeholder`, используйте селектор `getByPlaceholderText`.

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Поиск по placeholder
const searchInput = screen.getByPlaceholderText("Search...");
await userEvent.type(searchInput, "testing library");

// С регулярным выражением
const emailInput = screen.getByPlaceholderText(/enter.*email/i);
await userEvent.type(emailInput, "test@example.com");
```

### ByText

Чтобы найти текстовый элемент по его содержимому, используйте метод `getByText`.

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Поиск по точному тексту
const heading = screen.getByText("Welcome to our application");
expect(heading).toBeInTheDocument();

// С регулярным выражением (частичное совпадение)
const errorMessage = screen.getByText(/error.*occurred/i);
expect(errorMessage).toHaveClass("error");
```

### ByDisplayValue

Для поиска элемента по их текущему значению, используйте метод `getByDisplayValue`.

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Поиск input с конкретным значением
const emailInput = screen.getByDisplayValue("user@example.com");
expect(emailInput).toBeInTheDocument();

// Поиск с регулярным выражением
const searchInput = screen.getByDisplayValue(/search query/i);
```

### ByAltText

Для поиска изображений по тексту `alt`, используйте метод `getByAltText`.

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Поиск изображения по alt тексту
const logo = screen.getByAltText("Company Logo");
expect(logo).toBeInTheDocument();
expect(logo).toHaveAttribute("src", "/images/logo.png");
```

### ByTitle

Чтобы найти элемент по атрибуту title, используйте метод `getByTitle`.

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Поиск элемента по title атрибуту
const closeButton = screen.getByTitle("Close dialog");
await userEvent.click(closeButton);
```

### ByTestId

`getByTestId` используется как последний вариант, когда другие методы не подходят. Например, если вы используете `screen.getByTestId("submit-button")`, то найдте элемент с атрибутом `data-testid="submit-button"`

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Базовое использование
const submitButton = screen.getByTestId("submit-button");
await userEvent.click(submitButton);
```
