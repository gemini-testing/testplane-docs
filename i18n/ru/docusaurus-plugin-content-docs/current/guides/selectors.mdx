# Селекторы

Testplane предоставляет множество способов для поиска элементов на странице браузера с помощью селекторов. Для этого используются библиотеки `WebDriverIO` и `testing-library`. Селекторы позволяют точно идентифицировать элементы интерфейса, что необходимо для автоматизации тестирования.

## WebDriverIO

WebDriverIO — это Node.js-библиотека для автоматизации браузеров, которая реализует протокол WebDriver (W3C стандарт) В Testplane она используется для управления браузерами и взаимодействия с веб-элементами.

### CSS селекторы

#### По классу

Чтобы найти элемент на странице по классу, используйте селектор `".class-name"`.

```javascript
// Поиск кнопки с классом "btn-primary"
const button = await browser.$(".btn-primary");
await button.click();

// Поиск нескольких элементов
const menuItems = await browser.$$(".nav-item");
console.log("Количество пунктов меню: ${menuItems.length}");
```
Стоит использовать, если:

- класс является стабильным и не генерируется динамически;
- нужен быстрый и простой способ найти элемент;
- класс семантически описывает элемент (например, `.error-message`, `.success-banner`);
- вы работаете с компонентными библиотеками, где классы являются частью API.

#### По id

Чтобы найти элемент по `id`, используйте селектор вида `"#id"`.

```javascript
// Поиск формы id
const loginForm = await browser.$("#login-form");
const isDisplayed = await loginForm.isDisplayed();
```
Стоит использовать, если:

- вы работаете с критически важными элементами (формы, модальные окна, главные контейнеры);
- `id` является частью публичного API компонента;
- нужна максимальная производительность селектора (`id` — самый быстрый селектор).

#### По типу атрибута

Для поиска элемента по атрибуту, используйте селектор вида `input[type="name"]`.

```javascript
// Поиск всех чекбоксов
const checkboxes = await browser.$$("input[type="checkbox"]");
for (const checkbox of checkboxes) {
  await checkbox.click();
}

// Поиск email input
const emailInput = await browser.$("input[type="email"]");
await emailInput.setValue("test@example.com");

// Поиск скрытых полей
const hiddenField = await browser.$("input[type="hidden"][name="csrf_token"]");
const csrfValue = await hiddenField.getValue();
```

Стоит использовать, если:

- нужно найти все элементы определённого типа (все чекбоксы, все радиокнопки);
- вы тестируете формы и валидацию;
- нужно работать с семантическими HTML5 типами (`email`, `tel`, `url`, `date`);
- вам нужно убедиться, что используется правильный тип поля для `accessibility`;
- вы тестируете различное поведение для разных типов полей.

#### CSS-селекторы по атрибуту data-testid

Для поиска элементов, которые помечены дял тестирования, используйте селекторы по атрибуту `data-testid`.

```javascript
// Поиск элемента по data-testid
const userAvatar = await browser.$("[data-testid="user-avatar"]");
await userAvatar.waitForDisplayed({ timeout: 5000 });

// Клик по кнопке с data-testid
const deleteButton = await browser.$("[data-testid="delete-user-btn"]");
await deleteButton.click();

// Получение текста из элемента
const errorMessage = await browser.$("[data-testid="error-notification"]");
const text = await errorMessage.getText();
expect(text).toContain("Ошибка валидации");
```
Стоит использовать, если:

- создаёте селекторы специально для тестирования;
- нужна стабильность селекторов независимо от изменений UI/стилей;
- работаете в команде, где дизайнеры часто меняют классы и структуру;
- хотите явно пометить элементы, доступные для тестирования;

#### CSS-комбинированные селекторы

Комбинированные селекторы позволяют находить элементы в определённом контексте.

```javascript
// Потомок: кнопка внутри модального окна
const modalButton = await browser.$(".modal .close-button");
await modalButton.click();

// Прямой потомок: первый уровень вложенности
const navItem = await browser.$(".navigation > .nav-item");

// Соседний элемент
const errorLabel = await browser.$("input.invalid + .error-message");
const errorText = await errorLabel.getText();

// Сложная комбинация
const activeTab = await browser.$("ul.tabs > li.active > a[href^="#"]");
```

Стоит использовать, если:

- нужно найти элемент в определённом контексте;
- работаете с повторяющейся структурой;
- нужно убедиться в правильной вложенности элементов;
- простые селекторы слишком неспецифичны;
- тестируете связанные элементы.

#### CSS-псевдоселекторы

Псевдоселекторы позволяют выбирать элементы на основе их положения или состояния.

```javascript
// Первый элемент списка
const firstItem = await browser.$("ul.menu > li:first-child");
await firstItem.click();

// Последний элемент
const lastItem = await browser.$(".breadcrumb > li:last-child");
const currentPage = await lastItem.getText();

// N-ый элемент (третий пункт меню)
const thirdItem = await browser.$(".menu-item:nth-child(3)");

// Каждый второй элемент (чётные)
const evenRows = await browser.$$("table tr:nth-child(even)");

// Отключённые элементы
const disabledButtons = await browser.$$("button:disabled");
expect(disabledButtons.length).toBe(2);

// Проверенные чекбоксы
const checkedBoxes = await browser.$$("input[type="checkbox"]:checked");
```

Стоит использовать, если:

- тестируете позиционирование элементов;
- проверяете состояния элементов (`disabled`, `checked`, `focus`);
- работаете с таблицами и нужно выбрать определённую строку или столбец;
- тестируете паттерны (чётные/нечётные строки для `zebra-striping`);
- нужно найти элемент по его позиции, когда нет других идентификаторов.

### XPath селекторы

#### По тексту элемента

Чтобы найти элемент по содержащемуся в нем тексту, используйте селектор `//element[text()="text"]`.

```javascript
// Точное совпадение текста
const loginButton = await browser.$("//button[text()="Войти в систему"]");
await loginButton.click();

// Частичное совпадение
const successMessage = await browser.$("//div[contains(text(), "успешно")]");
await successMessage.waitForDisplayed();

// Текст с пробелами и переносами
const heading = await browser.$("//h1[normalize-space()="Добро пожаловать"]");

// Поиск по тексту в дочернем элементе
const card = await browser.$("//div[@class="card"][.//h3[text()="Premium план"]]");

// Case-insensitive поиск (XPath 2.0)
const link = await browser.$("//a[contains(translate(text(), "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ", "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"), "поиск")]");
```

Стоит использовать, если:

- текст элемента уникален и стабилен (названия кнопок, заголовки);
- нет других идентификаторов (нет `data-testid`, `id`, классов);
- тестируете, что правильный текст отображается в правильном месте;
- работаете с динамически генерируемым контентом, где единственный стабильный элемент — текст;
- нужно найти элемент, содержащий определённый текст внутри себя или в дочерних элементах.

#### По атрибутам

Для поиска элемента по атрибуту, используйте селектор вида `//element[@type="atribute"]`.

```javascript
// Поиск по одному атрибуту
const nameInput = await browser.$("//input[@name="username"]");
await nameInput.setValue("john_doe");

// Множественные условия (AND)
const activeModal = await browser.$("//div[@class="modal" and @data-visible="true"]");

// Условие OR
const submitBtn = await browser.$("//button[@type="submit" or @class="btn-submit"]");

// Поиск по началу значения атрибута
const imageJpg = await browser.$("//img[starts-with(@src, "/images/")]");

// Поиск по концу значения атрибута
const pdfLink = await browser.$("//a[substring(@href, string-length(@href) - 3) = ".pdf"]");

// Поиск по частичному совпадению атрибута
const dataElement = await browser.$("//div[contains(@data-component, "user-profile")]");

// NOT условие
const notDisabledButton = await browser.$("//button[not(@disabled)]");
```

Стоит использовать, если:

- нужны сложные условия поиска (комбинации атрибутов);
- работаете с динамическими атрибутами (`data`-атрибуты с переменными значениями);
- нужна гибкость в поиске (частичные совпадения, начало/конец строки);
- CSS-селекторы не могут выразить нужную логику;
- нужно найти элемент по отсутствию атрибута.

#### Навигация по DOM

Исползуя XPath, вы можете навигировать по DOM-дереву.

```javascript
// Прямой родитель
const parentDiv = await browser.$("//input[@name="email"]/..");

// Предок с условием
const formContainer = await browser.$("//input[@name="email"]/ancestor::form[@id="registration"]");

// Следующий сиблинг
const errorLabel = await browser.$("//input[@class="invalid"]/following-sibling::span[@class="error"][1]");

// Предыдущий сиблинг
const label = await browser.$("//input[@name="password"]/preceding-sibling::label[1]");

// Все потомки
const allInputs = await browser.$$("//form[@id="checkout"]//input");

// Прямые дети
const directChildren = await browser.$$("//ul[@class="menu"]/li");

// Поиск «дяди» элемента (родитель -> сиблинг родителя)
const siblingSection = await browser.$("//h2[text()="Контакты"]/../following-sibling::section[1]");
```

Стоит использовать, если:

- нужно найти элемент относительно другого известного элемента;
- структура DOM сложна, но относительные позиции стабильны;
- тестируете связанные элементы (label и input, ошибка рядом с полем);
- нужно подняться вверх по DOM-дереву от найденного элемента;
- работаете с семантической структурой HTML (заголовок и следующая за ним секция).

#### XPath: индексы и позиции

XPath позволяет выбирать элементы по их позиции в наборе результатов.

```javascript
// Первый элемент в результатах XPath
const firstButton = await browser.$("(//button[@class="action"])[1]");
await firstButton.click();

// Последний элемент
const lastItem = await browser.$("(//li[@class="menu-item"])[last()]");

// Второй элемент
const secondRow = await browser.$("(//table[@id="results"]//tr)[2]");

// Предпоследний
const secondToLast = await browser.$("(//div[@class="card"])[last()-1]");

// Диапазон элементов (все кроме первого)
const allButFirst = await browser.$$("(//li[@class="item"])[position() > 1]");

// Каждый третий элемент
const everyThird = await browser.$$("//div[@class="grid-item"][position() mod 3 = 0]");
```

Стоит использовать, если:

- нужен доступ к элементу по его позиции в наборе результатов;
- тестируете пагинацию или списки с определённым порядком;
- работаете с таблицами и нужна конкретная строка;
- нужен первый или последний элемент среди нескольких одинаковых;
- тестируете сортировку (проверка, что элемент на правильной позиции).

### Селекторы по Link Text

Селекторы по содержащемуся внутри тексту позволяют находить ссылки `(<a>)` по их тексту. Используйте `="text"`, чтобы найти элемент с точным текстом и `*="text"` для поиска по частичному совпадению текста.

```javascript
// Полное совпадение текста ссылки
const loginLink = await browser.$("=Войти в систему");
await loginLink.click();

// Частичное совпадение
const docsLink = await browser.$("*=Документация");
await docsLink.click();
```
Стоит использовать, если:

- работаете с навигационными ссылками с уникальным текстом;
- тестируете меню и навигацию сайта;
- текст ссылки является частью требований и не должен меняться;
- нужна простота и читаемость теста;
- тестируете наличие ссылок с правильным текстом на странице.

### Селекторы по имени тега

Чтобы найти элемент по их HTML-тегу, используйте селектор по имени тега.

```javascript
// Поиск первой кнопки на странице
const button = await browser.$("button");
await button.click();

// Все параграфы
const paragraphs = await browser.$$("p");
const textsArray = await Promise.all(
  paragraphs.map(p => p.getText())
);

// Все изображения
const images = await browser.$$("img");
for (const img of images) {
  const alt = await img.getAttribute("alt");
  expect(alt).not.toBe(""); // проверка accessibility
}

// Форма
const form = await browser.$("form");
await form.waitForDisplayed();

// Таблица
const table = await browser.$("table");
const rows = await table.$$("tr");
```

Стоит использовать, если:

- на странице один элемент данного типа (например, единственная форма);
- нужно получить все элементы определённого типа для массовой проверки;
- тестируете семантичность HTML (наличие правильных тегов);
- работаете с базовой HTML-структурой (`form`, `table`, `ul`);
- проводите accessibility-аудит (проверка всех `img` на наличие `alt`).

### React селекторы

Для поиска экомпонентов в React-приложении по их имени, используйте react-селекторы, например `react$("MyButton")` найдет компонент `MyButton`, а `react$("Button" { props: { variant: "primary", size: "large"}})` найдет кнопку с определенными параметрами.

```javascript
// Поиск React-компонента по имени
const myButton = await browser.react$("MyButton");
await myButton.click();

// С фильтрацией по параметрами
const primaryButton = await browser.react$("Button", {
  props: { variant: "primary", size: "large" }
});

// С фильтрацией по state
const openModal = await browser.react$("Modal", {
  state: { isOpen: true, activeTab: 'settings' }
});

// Все экземпляры компонента
const allCards = await browser.react$$("ProductCard");
console.log("Найдено карточек: ${allCards.length}");

// Вложенный поиск
const form = await browser.react$("CheckoutForm");
const submitButton = await form.react$("SubmitButton");

// С комплексными параметрами
const userProfile = await browser.react$("UserProfile", {
  props: {
    user: { id: 123, role: "admin" },
    editable: true
  }
});
```

Стоит использовать, если:

- работаете с React-приложением и имеете доступ к исходному коду;
- нужно найти компонент по его параметрам или `state`;
- тестируете, что компонент рендерится с правильными данными;
- структура `DOM` может меняться, но API компонента стабилен;
- нужна глубокая интеграция с React DevTools.

### Shadow DOM селекторы

Shadow DOM селекторы позволяют работать с элементами внутри Shadow DOM — инкапсулированной части DOM-дерева. Например, если у вас есть кастомный элемент `my-custom-element`, вы можете найти кнопку внутри его Shadow DOM с помощью `shadow$("button")`.

```javascript
// Простой доступ в Shadow DOM
const customElement = await browser.$("my-custom-element");
const button = await customElement.shadow$("button");
await button.click();

// Множественные элементы в Shadow DOM
const slotElements = await customElement.shadow$$(".slot-item");
```

Стоит использовать, если:

- работаете с Web Components и Custom Elements;
- приложение использует Shadow DOM для инкапсуляции стилей;
- тестируете компоненты из сторонних библиотек (Lit, Stencil, native Web Components);
- нужен доступ к элементам внутри shadow root;
- работаете с дизайн-системой на базе Web Components.

## Testing-library

Testing Library — это адаптер популярной философии Testing Library для Testplane. Она предоставляет селекторы, ориентированные на пользовательский опыт (как пользователи находят элементы).

### ByRole

`getByRole` — основной метод в Testing Library, который позволяет находить элементы по их ARIA-ролям. Например, если вы используете метод `screen.getByRole("button", { name: /submit/i })`, то найдете кнопку с текстом, содержащим `submit`.

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Поиск кнопки
const submitButton = screen.getByRole("button", { name: /submit/i });
await userEvent.click(submitButton);

// Поиск текстового поля
const emailInput = screen.getByRole('textbox', { name: /email/i });
await userEvent.type(emailInput, "test@example.com");

// Поиск чекбокса
const agreeCheckbox = screen.getByRole("checkbox", { name: /agree to terms/i });
await userEvent.click(agreeCheckbox);
```

Стоит использовать, если:

- для любых интерактивных элементов (кнопки, ссылки, поля ввода);
- для структурных элементов (`navigation`, `main`, `header`, `footer`);
- для форм и их элементов (`radio`, `checkbox`, `combobox`);
- для заголовков и важных текстовых элементов;
- для списков и таблиц.


### ByLabelText

Для поиска элементов форм по тексту их меток (`label`), используйте метод `getByLabelText`.

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Поиск по тексту label (полное совпадение)
const emailInput = screen.getByLabelText("Email Address");
await userEvent.type(emailInput, "user@example.com");

// Поиск с регулярным выражением (частичное совпадение, case-insensitive)
const passwordInput = screen.getByLabelText(/password/i);
await userEvent.type(passwordInput, "secure123");
```

Стоит использовать, если:

- работаете с формами;
- нужно найти input, select, textarea по связанной метке;
- занимаетесь тестированием доступности (наличие `label` обязательно для доступности);
- метка уникальна и описательна.

### ByPlaceholderText

Чтобы найти поле ввода по тексту `placeholder`, используйте селектор `getByPlaceholderText`.

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Поиск по placeholder
const searchInput = screen.getByPlaceholderText("Search...");
await userEvent.type(searchInput, "testing library");

// С регулярным выражением
const emailInput = screen.getByPlaceholderText(/enter.*email/i);
await userEvent.type(emailInput, "test@example.com");
```

Стоит использовать, если:

- у поля нет `label`, но есть `placeholder`;
- занимаетесь тестированием legacy-кода, где `placeholder` используется вместо `label`;
- `placeholder` достаточно описателен и уникален.

### ByText 

Чтобы найти текстовый элемент по его содержимому, используйте метод `getByText`.

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Поиск по точному тексту
const heading = screen.getByText("Welcome to our application");
expect(heading).toBeInTheDocument();

// С регулярным выражением (частичное совпадение)
const errorMessage = screen.getByText(/error.*occurred/i);
expect(errorMessage).toHaveClass("error");
```

Стоит использовать, если:

- необходимо найти неинтерактивные текстовые элементов (параграфы, заголовки, уведомления);
- занимаетесь проверкой отображения текста на странице;
- текст уникален и является частью требований.

### ByDisplayValue

Для поиска элемента по их текущему значению, используйте метод `getByDisplayValue`.

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Поиск input с конкретным значением
const emailInput = screen.getByDisplayValue("user@example.com");
expect(emailInput).toBeInTheDocument();

// Поиск с регулярным выражением
const searchInput = screen.getByDisplayValue(/search query/i);
```

Стоит использовать, если:

- необходимо протестировать предзаполненных форм (edit forms, profile pages);
- нужно проверить установку корректного значения после действия;
- необходимо найти элемент по его текущему значению, а не по label.

### ByAltText

Для поиска изображений по тексту `alt`, используйте метод `getByAltText`.

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Поиск изображения по alt тексту
const logo = screen.getByAltText("Company Logo");
expect(logo).toBeInTheDocument();
expect(logo).toHaveAttribute("src", "/images/logo.png");
```

Стоит использовать, если:

- нужно работать с изображениями (`<img>`, `<area>`, `<input type="image">`);
- необходимо проверить доступность изображений (наличие `alt` обязательно);
- `alt`-текст достаточно описателен и уникален.

### ByTitle

Чтобы найти элемент по атрибуту title, используйте метод getByTitle.

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Поиск элемента по title атрибуту
const closeButton = screen.getByTitle("Close dialog");
await userEvent.click(closeButton);
```

Стоит использовать, если:

- необходимо работать с элементами, которые используют `title` для `tooltips`;
- нужно протестировать `iframe`-элементы (`title` обязателен для доступности);
- нужно взаимодействовать с `SVG`-элементами (`title` внутри `SVG` для описания).

### ByTestId

`getByTestId` используется как последний вариант, когда другие методы не подходят. Например, если вы используете `screen.getByTestId("submit-button")`, то найдте элемент с атрибутом `data-testid="submit-button"`

```javascript
import { screen } from "@testing-library/dom";
import userEvent from "@testing-library/user-event";

// Базовое использование
const submitButton = screen.getByTestId("submit-button");
await userEvent.click(submitButton);
```

